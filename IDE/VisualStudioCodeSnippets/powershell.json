{
/*
	// Place your snippets for PowerShell here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"Print to console": {
		"prefix": "log",
		"body": [
			"console.log('$1');",
			"$2"
		],
		"description": "Log output to console"
	}
*/
"New Type Accelerator": {
	"prefix": "newaccel",
	"body": [
		"\\$xlr=[psobject].Assembly.GetType('System.Xml.XmlDocument')",
		"\\$xlr::Add('xml',\\$xlr)",
		"\\$xmlobject = [xml]::new()",
		"$0"
	],
	"description": "New Type Accelerator"
},
"Add To EnvPath": {
    "prefix": "addtopath",
    "body": [
        "if (\\$env:Path[-1] -eq \";\") {",
		"    \\$env:Path = \"\\$env:Path\\$MSBuildParentDir\"",
		"}",
		"else {",
		"    \\$env:Path = \"\\$env:Path;\\$MSBuildParentDir\"",
		"}",
		"$0"
    ],
    "description": "Add to EnvPath"
},
"Array": {
    "prefix": "arr",
    "body": [
        "\\$array = @(",
		"    \"obj1\"",
		"    \"obj2\"",
		"    \"obj3\"",
		")",
		"",
		"# Delete old \\$array object and create new \\$array object with same name and string \"obj4\" added",
		"\\$array += \"obj4\"",
		"",
		"# Delete old \\$array object and create new \\$array object with the same name while retaining the", 
		"# original object (and its type/property info) as opposed to simply adding the object's value to the array",
		"\\$array +=, \\$obj5",
		"# As a result of the above, assuming that \\$obj5.GetType().Name -eq \"DirectoryInfo\",",
		"# \\$array[4].GetType().Name should also -eq \"DirectoryInfo\" as opposed to \"String\" or some other type.",
		"",
		"# Convert Array to Systems.Collection.ArrayList to allow use of Add/Remove Methods",
		"# The Add/Remove Methods simply modify the existing [System.Collection.ArrayList] as opposed to destroying",
		"# and creating a new one with the same name",
		"[System.Collection.ArrayList]\\$newarray = \\$array",
		"\\$newarray.Add(\"obj6\")",
		"\\$newarray.Remove(\"obj6\")",
		"$0"
    ],
    "description": "Array"
},
"Background Job": {
    "prefix": "bgjobscript",
    "body": [
		"Start-Job -Name myJob -InitializationScript {Import-Module BitsTransfer} -FilePath myFile.ps1",
		"$0"
    ],
    "description": "Background Job"
},
"Begin": {
    "prefix": "beg",
    "body": [
		"begin {",
		"}",
		"$0"
    ],
    "description": "Begin"
},
"Bound Parameters": {
    "prefix": "boundparams",
    "body": [
		"\\$BoundParamsArrayOfKVP = \\$PSBoundParameters.GetEnumerator() | foreach {\\$_}",
		"$0"
    ],
    "description": "Bound Parameters"
},
"Cmdlet Binding": {
    "prefix": "cmdletbinding",
    "body": [
        "[CmdletBinding(",
        "    DefaultParameterSetName='Parameter Set 1',", 
        "    SupportsShouldProcess=\\$true,", 
        "    PositionalBinding=\\$false,",
        "    HelpUri = 'http://www.microsoft.com/',",
        "    SupportsPaging = \\$false,",
		"    ConfirmImpact='Medium'",
		")]",
		"[Alias('vn','verbn','vnoun')]",
		"[OutputType([String])]",
		"$0"
    ],
    "description": "Cmdlet Binding"
},
"String To ScriptBlock": {
    "prefix": "stringtoscript",
    "body": [
		"\\$scriptBlock = [scriptblock]::Create(\\$string)",
		"$0"
    ],
    "description": "String To ScriptBlock"
},
"Temp File Or Dir": {
    "prefix": "tempitem",
    "body": [
        "#\\$tmpDir = [IO.Path]::GetTempPath()",
		"#\\$tmpFile = [IO.Path]::GetTempFileName()",
		"",
		"\\$tempfile = [IO.Path]::Combine([IO.Path]::GetTempPath(), [IO.Path]::GetRandomFileName())",
		"New-Item -Type File -path \\$tempfile",
		"",
		"\\$tempDirectory = [IO.Path]::Combine([IO.Path]::GetTempPath(), [IO.Path]::GetRandomFileName())",
		"[IO.Directory]::CreateDirectory(\\$tempDirectory)",
		"$0"
    ],
    "description": "Temp File or Dir"
},
"New Html Dom Object": {
    "prefix": "htmlobj",
    "body": [
        "if (Test-Path \"C:\\Program Files (x86)\\Microsoft.NET\\Primary Interop Assemblies\\Microsoft.mshtml.dll\") {",
		"    Add-Type -Path \"C:\\Program Files (x86)\\Microsoft.NET\\Primary Interop Assemblies\\Microsoft.mshtml.dll\"",
		"}",
		"elseif (Test-Path \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\IDE\\PublicAssemblies\\Microsoft.mshtml.dll\") {",
		"    Add-Type -Path \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\IDE\\PublicAssemblies\\Microsoft.mshtml.dll\"",
		"}",
		"else {",
		"    Invoke-WebRequest -Uri \"http://packages.nuget.org/api/v1/package/Unofficial.Microsoft.mshtml\" -OutFile \"\\$HOME\\Downloads\\Unofficial.Microsoft.mshtml.zip\"",
		"    Expand-Archive -Path \"\\$HOME\\Downloads\\Unofficial.Microsoft.mshtml.zip\" -DestinationPath \"\\$HOME\\Downloads\\Unofficial-Microsoft-mshtml\"",
		"    \\$mshtmlDLLPath = \\$(Get-ChildItem \\$HOME\\Downloads\\Unofficial-Microsoft-mshtml\\ -Recurse | Where-Object {\\$_.Name -eq \"Microsoft.mshtml.dll\"}).FullName",
		"    Add-Type -Path \\$mshtmlDLLPath",
		"}",
		"",
		"\\$RawHtml = @\"",
		"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">",
		"<html xmlns=\"http://www.w3.org/1999/xhtml\">",
		"<head>",
		"    <style>",
		"        TABLE {border-width: 1px;border-style: solid;border-color: black;border-collapse: collapse;}",
		"        TH {border-width: 1px;padding: 3px;border-style: solid;border-color: black;background-color: #6495ED;}",
		"        TD {border-width: 1px;padding: 3px;border-style: solid;border-color: black;}",
		"        .odd  { background-color:#ffffff; }",
		"        .even { background-color:#dddddd; }",
		"        TR:Nth-Child(Even) {Background-Color: #dddddd;}",
		"        TR:Hover TD {Background-Color: #C1D5F8;}",
		"    </style>",
		"</head>",
		"<body>",
		"    <h2>Call Count For December</h2>",
		"    <h4>This Report Has Been Saved To \"C:\\Users\\pddomain\\CallActivityReportDecember.html\"</h4>",
		"    <h3>Total Number of Calls for filter  is 26</h3>",
		"    <table>",
		"        <colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup>",
		"        <tr><th>Date/Time</th><th>Duration</th><th>Call Type</th><th>From</th><th>To</th><th>Acct. Code</th><th>FromPhoneNumber</th><th>FromName</th><th>FromExt</th><th>ToPhoneNumber</th><th>ToName</th><th>ToExt</th><th>ToGroup</th><th>ToVoicemail</th><th>ToForwardedCall</th></tr>",
		"        <tr><td>12/31/2016 12:27:48 PM</td><td>00:00:14</td><td>Incoming</td><td>(610) 733-8293 Consign FIELD MARY&quot; &quot;</td><td>6106478632</td><td>1</td><td>6107338293</td><td>Consign FIELD MARY</td><td></td><td>6106478632</td><td></td><td>6106478632</td><td></td><td></td><td>6106478632</td></tr>",
		"    </table>",
		"    <h3>Report Run on 04/19/2017 08:26:40</h3>",
		"</body>",
		"</html>",
		"\"@",
		"",
		"\\$NewHTMLObject = New-Object mshtml.HTMLDocumentClass",
		"\\$ConvertToHtmlObj = Import-Clixml -Path \"C:\\Users\\pddomain\\CallCountReportObj.xml\"",
		"\\$ConvertToHtmlObjAsString = \\$ConvertToHtmlObj.ToString()",
		"\\$NewHTMLObject.IHTMLDocument2_write(\\$ConvertToHtmlObjAsString)",
		"$0"
    ],
    "description": "New Html Dom Object"
},
"This Script Dir": {
    "prefix": "thisscriptdir",
    "body": [
        "\\$ScriptDir = \\$PSCommandPath | Split-Path -Parent",
		"\\$ScriptFile = \\$PSCommandPath | Split-Path -Leaf",
		"$0"
    ],
    "description": "This Script Dir"
},
"Current User": {
    "prefix": "currentuser",
    "body": [
		"[System.Security.Principal.WindowsIdentity]::GetCurrent()",
		"$0"
    ],
    "description": "Current User"
},
"Do Until": {
	"prefix": "dountil",
	"body": [
		"do",
		"{",
		"    \\$1",
		"} until (\\$x -gt 0)"
	],
	"description": "Do Until"
},
"Do While": {
	"prefix": "dowhile",
	"body": [
		"do",
		"{",
		"    \\$1",
		"} while (\\$true)"
	],
	"description": "Do While"
},
"DSC Class-Based Resource Provider": {
    "prefix": "dscprovclass",
    "body": [
        "[DscResource()]",
		"class NameOfResource {",
		"    [DscProperty(Key)]",
		"    [string] \\$KeyName",
		"",	
		"    # Gets the resource's current state.",
		"    [NameOfResource] Get() {",
		"        return \\$this",
		"    }",
		"",			
		"    # Sets the desired state of the resource.",
		"    [void] Set() {",
		"    }",
		"",
		"    # Tests if the resource is in the desired state.",
		"    [bool] Test() {",	
		"    }",
		"}",
		"$0"
    ],
    "description": "DSC Class-Based Resource Provider"
},
"DSC Config Example": {
    "prefix": "dscconfigexamp",
    "body": [
        "configuration Name",
		"{",
		"    # One can evaluate expressions to get the node list",
		"    # E.g: .Where(\"Role -eq Web\").NodeName",
		"    node (\"Node1\",\"Node2\",\"Node3\")",
		"    {",
		"        # Call Resource Provider",
		"        # E.g: WindowsFeature, File",
		"        WindowsFeature FriendlyName",
		"        {",
		"            Ensure = \"Present\"",
		"            Name = \"Feature Name\"",
		"        }",
		"",
		"        File FriendlyName",
		"        {",
		"            Ensure = \"Present\"",
		"            SourcePath =",
		"            DestinationPath =",
		"            Type = \"Directory\"",
		"           DependsOn = \"[WindowsFeature]FriendlyName\"",
		"        }",
		"    }",
		"}",
		"$0"
    ],
    "description": "DSC Config Example"
},
"DSC Function-Based Resource Provider": {
    "prefix": "dscprovfun",
    "body": [
        "Function Get-TargetResource",
		"{",
		"    # TODO: Add parameters here",
		"    # Make sure to use the same parameters for",
		"    # Get-TargetResource, Set-TargetResource, and Test-TargetResource",
		"    param(",
		"    )",
		"}",
		"",
		"Function Set-TargetResource",
		"{",
		"    # TODO: Add parameters here",
		"    # Make sure to use the same parameters for",
		"    # Get-TargetResource, Set-TargetResource, and Test-TargetResource",
		"    param(",
		"    )",
		"}",
		"",
		"Function Test-TargetResource",
		"{",
		"    # TODO: Add parameters here",
		"    # Make sure to use the same parameters for",
		"    # Get-TargetResource, Set-TargetResource, and Test-TargetResource",
		"    param(",
		"    )",
		"}",
		"$0"
    ],
    "description": "DSC Function-Based Resource Provider"
},
"Set-PSDebug": {
    "prefix": "setdebug",
    "body": [
		"Set-PSDebug -Step; foreach (\\$i in 1..3) {\\$i}",
		"$0"
    ],
    "description": "Set-PSDebug"
},
"Environment Special Directory Documents": {
    "prefix": "mydocs",
    "body": [
        "\\$MyDocs = [Environment]::GetFolderPath([Environment+SpecialFolder]::MyDocuments)"
    ],
    "description": "Environment Special Directory Documents"
},
"Error": {
    "prefix": "error",
    "body": [
        "if (! \\$(Test-Path \\$SamplePath)) {",
		"    Write-Error \"The path \\$SamplePath was not found! Halting!\"",
		"    \\$global:FunctionResult = \"1\"",
		"    return",
		"}",
		"$0"
    ],
    "description": "Error"
},
"Validate Path": {
    "prefix": "validatepath",
    "body": [
        "# FOR THE LOVE OF GOD, USE: https://regex101.com to figure out regex",
		"",
		"# \\$RegexURL comes from: http://daringfireball.net/2010/07/improved_regex_for_matching_urls",
		"# Distill one or more strings that are valid paths from unknown object",
		"\\$RegexLocalOrUNCPath = '^(([a-zA-Z]:\\\\\\\\)|(\\\\\\\\\\\\\\\\))(((?![<>:\"\\/\\\\\\\\|?*]).)+((?<![ .])\\\\\\\\)?)*\\$'",
		"\\$RegexURL = \"(?i)\\b((?:https?://|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'`\".,<>?«»“”‘’]))\"",
		"",
		"\\$RegexDirectoryPath = '^(([a-zA-Z]:\\\\\\\\)|(\\\\\\\\\\\\\\\\))((?![.<>:\"\\/\\\\\\\\|?*]).)+((?![.<>:\"\\/|?*]).)+\\$'",
		"\\$RegexFilePath = '^(([a-zA-Z]:\\\\\\\\)|(\\\\\\\\\\\\\\\\))((?![.<>:\"\\/\\\\\\\\|?*]).)+((?![<>:\"\\/|?*]).)+((.*?\\.)|(.*?\\.[\\w]+))+\\$'",
		"",
		"# Invalid FileName Characters",
		"\\$InvalidFileNameChars = [System.IO.Path]::GetInvalidFileNameChars()",
		"\\$InvalidFileNameChars = \\$InvalidFileNameChars | foreach {if ($_ -eq '\\\\') {'\\\\\\\\'} else {$_}}",
		"\\$InvalidFileNameChars | foreach {",
		"    if (\\$FileName -match $_) {",
		"        Write-Error \"The filename for the shortcut (i.e. \\$FileName) contains an illegal character '\\$_' ! Halting!",
		"        \\$global:FunctionResult = \"1\"",
		"        return",
		"    }",
		"}",
		"",
		"# Finding potential Local or UNC in a block of text",
		"\\$TextBlock = Get-Content \\$HOME\textblock.txt",
		"\\$PotentialPathsArray = \\$(\\$TextBlock | Select-String -Pattern \\$RegexLocalOrUNCPath -AllMatches).Matches.Value",
		"\\$UpdatedPotentialPathsArray = foreach (\\$potentialpath in \\$PotentialPathsArray) {",
		"    if (\\$([uri]\\$potentialpath).IsAbsoluteURI -and \\$(\\$([uri]\\$potentialpath).IsLoopBack -or \\$([uri]\\$potentialpath).IsUnc)) {",
		"        \\$potentialpath",
		"    }",
		"}",
		"",
		"# Validating a string that is supposed to be a Local or UNC Path",
		"if ( !\\$(\\$([uri]\\$TargetDir).IsAbsoluteURI -and \\$(\\$([uri]\\$TargetDir).IsLoopBack -or \\$([uri]\\$TargetDir).IsUnc)) ) {",
		"    Write-Error \"\\$TargetDir is not a valid directory path! Halting!\"",
		"    \\$global:FunctionResult = \"1\"",
		"    return",
		"}",
		"",
		"# Determine if string is a URL, a local path, or a UNC path",
		"if ([uri]\\$TargetString.Scheme -match \"http\") {",
		"    Write-Host \"\\$TargetSring is a URL\"",
		"}",
		"if ([uri]\\$TargetString.Scheme -eq \"file\" -and [uri]\\$TargetString.Host -ne \\$null) {",
		"    Write-Host \"\\$TargetString is a UNC path\"",
		"}",
		"if ([uri]\\$TargetString.Scheme -eq \"file\" -and [uri]\\$TargetString.Host -eq \\$null) {",
		"    Write-Host \"\\$TargetString is a local path\"",
		"}",
		"$0"
    ],
    "description": "Validate Path"
},
"For Loop": {
    "prefix": "for",
    "body": [
        "for (\\$i=0; \\$i -lt \\$array.Count; \\$i++) {",
		"",
		"}",
		"$0"
    ],
    "description": "For Loop"
},
"ForEach": {
    "prefix": "foreach",
    "body": [
        "foreach (\\$item in \\$collection) {",
		"",
		"}",
		"$0"
    ],
    "description": "ForEach"
},
"Function Block Advanced": {
    "prefix": "funadv",
    "body": [
		"<#",
		".SYNOPSIS",
		"    Short description",
		".DESCRIPTION",
		"    Long description",
		".NOTES",
		"    DEPENDENCEIES",
		"        Helper scripts/functions and/or binaries needed for the function to work.",
		".PARAMETER",
		"    N parameter",
		".PARAMETER",
		"    N+1 parameter",
		".EXAMPLE",
		"    Example of how to use this cmdlet",
		".EXAMPLE",
		"    Another example of how to use this cmdlet",
		".INPUTS",
		"    Inputs to this cmdlet (if any)",
		".OUTPUTS",
		"    Output from this cmdlet (if any)",
		"#>",
		"",
		"function Verb-Noun {",
		"    [CmdletBinding(",
		"        DefaultParameterSetName='Parameter Set 1',",
		"        PositionalBinding=\\$true,",
		"        ConfirmImpact='Medium'",
		"    )]",
		"    [Alias('vn','verbn','vnoun')]",
		"",
		"    <#",
		"    All PS 5.1 Parameter Arguments and Attributes are as follows:",
		"    (See: https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.core/about/about_functions_advanced_parameters)",
		"",
		"        Arguments:",
		"        Syntax is, for example -",
		"        [parameter(Mandatory=\\$true,Position=1)])",
		"",
		"        Mandatory, Position, ParameterSetName, ValueFromPipeline, ValueFromPipelineByPropertyName,",
		"        ValueFromRemainingArguments, HelpMessage",
		"",
		"        Attributes:",
		"        Syntax is somewhere immediately before the parameter name, for example -",
		"        [Alias(\"CN\",\"MachineName\")]",
		"        \\$ComputerName",
		"",
		"        Alias, AllowNull, AllowEmptyString, AllowEmptyCollection, ValidateCount, ValidateLength,",
		"        ValidatePattern, ValidateRange, ValidateScript, ValidateSet, ValidateNotNull,",
		"        ValidateNotNullOrEmpty",
		"    #>",
		"",
		"    Param(",
		"        [Parameter(",
		"            Mandatory=\\$False,",
		"            ParameterSetName='Parameter Set 1'",
		"        )]",
		"        [Alias(\"helperdir\")]",
		"        [string]\\$HelperFunctionSourceDirectory = \\$(Read-Host -Prompt \"Please enter the full path to the directory that contains the [HELPER] script(s)/function(s)\"),",
		"",
		"        [Parameter(",
		"            Mandatory=\\$False,",
		"            ParameterSetName='Parameter Set 1'",
		"        )]",
		"        [Alias(\"outdir\")]",
		"        [string]\\$OutputDirectory = \\$(Read-Host -Prompt \"Please enter the full path to the directory where all output files will be written\")",
		"    )",
		"",	
		"    # Adding the Dynamic Parameter \"dp1\" that is revealed via tab completion if \\$OutputDirectory matches \"C:\\boop\"",
		"    DynamicParam {",
		"        if (\\$OutputDirectory -match \"C:\\boop\") {",
		"            \\$attributes = New-Object System.Management.Automation.ParameterAttribute",
		"            \\$attributes.ParameterSetName = \"__AllParameterSets\"",
		"            \\$attributes.Mandatory = \\$false",
		"",
		"            \\$attributeCollection = New-Object -Type System.Collections.ObjectModel.Collection",
		"            [System.Attribute]\\$attributeCollection.Add(\\$attributes)",
		"",
		"            \\$dynParam1 = New-Object -Type System.Management.Automation.RuntimeDefinedParameter(\"dp1\", [Int32], \\$attributeCollection)",
		"",
		"            \\$paramDictionary = New-Object -Type System.Management.Automation.RuntimeDefinedParameterDictionary",
		"            \\$paramDictionary.Add(\"dp1\", \\$dynParam1)",
		"            return \\$paramDictionary",
		"        }",
		"    }",
		"",
		"    ##### REGION Helper Functions and Libraries #####",
		"",
		"    ## BEGIN Sourced Helper Functions ##",
		"",
		"    ## END Sourced Helper Functions ##",
		"",
		"    ## BEGIN Native Helper Functions ##",
		"",
		"    ## END Native Helper Functions ##",
		"",
		"    ##### REGION END Helper Functions and Libraries #####",
		"",
		"",
		"    ##### BEGIN Variable/Parameter Transforms and PreRun Prep #####",
		"",
		"    ##### END Variable/Parameter Transforms and PreRun Prep #####",
		"",
		"",
		"    ##### BEGIN Parameter Validation #####",
		"",
		"    ##### END Parameter Validation #####",
		"",
		"",
		"    ##### BEGIN Main Body #####",
		"",
		"    ##### END Main Body #####",
		"",
		"}",
		"$0"
    ],
    "description": "Function Block Advanced"
},
"Function Block Advanced Complete": {
    "prefix": "funadvcom",
    "body": [
        "<#",
		".SYNOPSIS",
		"    Short description",
		".DESCRIPTION",
		"    Long description",
		".NOTES",
		"    DEPENDENCIES",
		"        Helper scripts/functions and/or binaries needed for the function to work.",
		".PARAMETER",
		"    N parameter",
		".PARAMETER",
		"    N+1 parameter",
		".EXAMPLE",
		"    Example of how to use this cmdlet",
		".EXAMPLE",
		"    Another example of how to use this cmdlet",
		".INPUTS",
		"    Inputs to this cmdlet (if any)",
		".OUTPUTS",
		"    Output from this cmdlet (if any)",
		".COMPONENT",
		"    The component this cmdlet belongs to",
		".ROLE",
		"    The role this cmdlet belongs to",
		".FUNCTIONALITY",
		"    The functionality that best describes this cmdlet",
		"#>",
		"function Verb-Noun {",
		"    [CmdletBinding(",
		"        DefaultParameterSetName='Parameter Set 1', ",
		"        SupportsShouldProcess=\\$true, ",
		"        PositionalBinding=\\$false,",
		"        HelpUri = 'http://www.microsoft.com/',",
		"        SupportsPaging = \\$false,",
		"        ConfirmImpact='Medium'",
		"    )]",
		"    [Alias('vn','verbn','vnoun')]",
		"    [OutputType([String])]",
		"",
		"    <#",
		"    All PS 5.1 Parameter Arguments and Attributes are as follows:",
		"    (See: https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.core/about/about_functions_advanced_parameters)",
		"    ",
		"        Arguments:",
		"        Syntax is, for example -",
		"        [parameter(Mandatory=\\$true,Position=1)])",
		"",
		"        Mandatory, Position, ParameterSetName, ValueFromPipeline, ValueFromPipelineByPropertyName,",
		"        ValueFromRemainingArguments, HelpMessage",
		"        ",
		"        Attributes:",
		"        Syntax is somewhere immediately before the parameter name, for example -",
		"        [Alias(\"CN\",\"MachineName\")]",
		"        \\$ComputerName",
		"",
		"        Alias, AllowNull, AllowEmptyString, AllowEmptyCollection, ValidateCount, ValidateLength,",
		"        ValidatePattern, ValidateRange, ValidateScript, ValidateSet, ValidateNotNull,",
		"        ValidateNotNullOrEmpty",
		"    #>",
		"",
		"    Param",
		"    (",
		"        # \\$HelperFunctionSourceDirectory help description",
		"        [Parameter(",
		"            Mandatory=\\$true, ",
		"            ValueFromPipeline=\\$true,",
		"            ValueFromPipelineByPropertyName=\\$true, ",
		"            ValueFromRemainingArguments=\\$false, ",
		"            Position=0,",
		"            ParameterSetName='Parameter Set 1'",
		"        )]",
		"        [ValidateNotNull()]",
		"        [ValidateNotNullOrEmpty()]",
		"        [ValidateCount(0,5)]",
		"        [ValidateSet(\"sun\", \"moon\", \"earth\")]",
		"        [Alias(\"hfsd\")] ",
		"        [string]\\$HelperFunctionSourceDirectory = \\$(Read-Host -Prompt \"Please enter the full path to the directory that contains the [HELPER] script(s)/function(s)\"),",
		"",
		"        # \\$Number help description",
		"        [Parameter(",
		"            Position=1,",
		"            ParameterSetName='Parameter Set 1'",
		"        )]",
		"        [AllowNull()]",
		"        [AllowEmptyCollection()]",
		"        [AllowEmptyString()]",
		"        [ValidateScript({\\$true})]",
		"        [ValidateRange(0,5)]",
		"        [int]\\$Number,",
		"",
		"        [Parameter(",
		"            Position=2,",
		"            ParameterSetName='Another Parameter Set'",
		"        )]",
		"        [ValidatePattern(\"[a-z]*\")]",
		"        [ValidateLength(0,15)]",
		"        [string]\\$OutputDirectory = \\$(Read-Host -Prompt \"Please enter the full path to the directory where all output files will be written\")",
		"",
		"        # \\$IPAddress help description",
		"        [Parameter(",
		"            Position=3,",
		"            ParameterSetName='Another Parameter Set'",
		"        )]",
		"        [ValidateScript({",
		"            \\$_ -match [IPAddress]",
		"        })]",
		"        \\$IPAddress",
		"    )",
		"",
		"    # Adding the Dynamic Parameter \"dp1\" that is revealed via tab completion if \\$OutputDirectory matches \"C:\\boop\"",
		"    DynamicParam {",
		"        if (\\$OutputDirectory -match \"C:\\boop\") {",
		"            \\$attributes = New-Object System.Management.Automation.ParameterAttribute",
		"            \\$attributes.ParameterSetName = \"__AllParameterSets\"",
		"            \\$attributes.Mandatory = \\$false",
		"",
		"            \\$attributeCollection = New-Object -Type System.Collections.ObjectModel.Collection",
		"            [System.Attribute]\\$attributeCollection.Add(\\$attributes)",
		"",
		"            \\$dynParam1 = New-Object -Type System.Management.Automation.RuntimeDefinedParameter(\"dp1\", [Int32], \\$attributeCollection)",
		"",
		"            \\$paramDictionary = New-Object -Type System.Management.Automation.RuntimeDefinedParameterDictionary",
		"            \\$paramDictionary.Add(\"dp1\", \\$dynParam1)",
		"            return \\$paramDictionary",
		"        }",
		"    }",
		"",
		"    Begin {",
		"    ##### REGION Helper Functions and Libraries #####",
		"",
		"    ## BEGIN Sourced Helper Functions ##",
		"",
		"    ## END Sourced Helper Functions ##",
		"",
		"    ## BEGIN Native Helper Functions ##",
		"",
		"    ## END Native Helper Functions ##",
		"",
		"    ##### REGION END Helper Functions and Libraries #####",
		"",
		"",
		"    ##### BEGIN Variable/Parameter Transforms and PreRun Prep #####",
		"",
		"    ##### END Variable/Parameter Transforms and PreRun Prep #####",
		"",
		"",
		"    ##### BEGIN Parameter Validation #####",
		"",
		"    ##### END Parameter Validation #####",
		"    }",
		"",
		"    Process {",
		"        if (\\$pscmdlet.ShouldProcess(\"Target\")) {",
		"        ##### BEGIN Main Body #####",
		"",
		"        ##### END Main Body #####",
		"        }",
		"    }",
		"",
		"    End {",
		"        ##### BEGIN Cleanup #####",
		"",
		"        ##### END Cleanup #####",
		"    }",
		"}",
		"$0"
    ],
    "description": "Function Block Advanced Complete"
},
"Function Block Simple": {
    "prefix": "funsim",
    "body": [
        "# For more advanced PowerShell Function Parameter Arguments and Attributes, see:",
		"# https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.core/about/about_functions_advanced_parameters",
		"",
		"function Verb-Noun",
		"{",
		"    [CmdletBinding()]",
		"    [Alias('vn','verbn','vnoun')]",
		"    Param( ",
		"        [Parameter(Mandatory=\\$False)]",
		"        \\$HelperFunctionSourceDirectory = \\$(Read-Host -Prompt \"Please enter the full path to the directory that contains the [HELPER] script(s)/function(s)\"),",
		"        [Parameter(Mandatory=\\$False)]",
		"        \\$OutputDirectory = \\$(Read-Host -Prompt \"Please enter the full path to the directory where all output files will be written\")",
		"",
		"    )",
		"",
		"    ##### REGION Helper Functions and Libraries #####",
		"",
		"    ## BEGIN Sourced Helper Functions ##",
		"",
		"    ## END Sourced Helper Functions ##",
		"",
		"    ## BEGIN Native Helper Functions ##",
		"",
		"    ## END Native Helper Functions ##",
		"",
		"    ##### REGION END Helper Functions and Libraries #####",
		"",
		"",
		"    ##### BEGIN Variable/Parameter Transforms and PreRun Prep #####",
		"",
		"    ##### END Variable/Parameter Transforms and PreRun Prep #####",
		"",
		"",
		"    ##### BEGIN Parameter Validation #####",
		"",
		"    ##### END Parameter Validation #####",
		"",
		"",
		"    ##### BEGIN Main Body #####",
		"",
		"    ##### END Main Body #####",
		"",
		"}",
		"$0"
    ],
    "description": "Function Block Simple"
},
"Get Registered COM Classes": {
    "prefix": "comobject",
    "body": [
        "# Get All Available Com Objects",
		"\\$GetComClasses = gwmi -Class win32_classiccomclasssetting -ComputerName .",
		"\\$GetComClasses | Where-Object {\\$_.progid -like \"*html*\"}",
		"",
		"# Create New Com Object by referencing ProgID",
		"\\$NewHTMLObject = New-Object -ComObject \"htmlfile\"",
		"",
		"# Create New Com Object by referencing GUID",
		"\\$clsid = New-Object Guid '25336920-03F9-11cf-8FD0-00AA00686F13'",
		"\\$type = [Type]::GetTypeFromCLSID(\\$clsid)",
		"\\$NewHTMLObject = [Activator]::CreateInstance(\\$type)",
		"$0"
    ],
    "description": "Get Registered COM Classes"
},
"Get-Member All": {
    "prefix": "gm",
    "body": [
		"\\$test | Get-Member -View All -Force",
		"$0"
    ],
    "description": "Get-Member All"
},
"GUI Choose From List": {
    "prefix": "guichoice",
    "body": [
        "\\$ChoiceOptions = @(1,2,3)",
		"\\$DefaultChoice = 0",
		"\\$ChoiceDescription = New-Object System.Collections.ObjectModel.Collection[System.Management.Automation.Host.ChoiceDescription]",
		"\\$ChoiceOptions | foreach  {",
		"    \\$ChoiceDescription.Add(",
		"        (New-Object \"System.Management.Automation.Host.ChoiceDescription\" -ArgumentList \\$_)",
		"    )",
		"}",
		"\\$Host.ui.PromptForChoice(\"Caption\", \"message\", \\$ChoiceDescription, \\$DefaultChoice)",
		"$0"
    ],
    "description": "GUI Choose From List"
},
"GUI Message Box": {
    "prefix": "guimsgbox",
    "body": [
        "\\$AssemblyFullInfo = [System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms').FullName",
		"[void][reflection.assembly]::Load(\\$AssemblyFullInfo)",
		"[void][System.Windows.Forms.MessageBox]::Show(Text,Caption)",
		"$0"
    ],
    "description": "GUI Message Box"
},
"GUI Message Box Yes No": {
    "prefix": "guimsgboxyesno",
    "body": [
		"\\$AssemblyFullInfo = [System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms').FullName",
		"[void][reflection.assembly]::Load(\\$AssemblyFullInfo)",
		"if ([System.Windows.Forms.MessageBox]::Show(\"Question\", \"Caption\",[System.Windows.Forms.MessageBoxButtons]::YesNo) -eq \"Yes\")",
		"{",
		"}",
		"$0"
    ],
    "description": "GUI Message Box Yes No"
},
"Hashtable": {
    "prefix": "hashtable",
    "body": [
        "@{",
		"    key = \"value\"",
		"    key = 0",
		"}",
		"$0"
    ],
    "description": "Hashtable"
},
"Help Block": {
    "prefix": "helpblock",
    "body": [
        "<#",
		".SYNOPSIS",
		"    Short description",
		".DESCRIPTION",
		"    Long description",
		".NOTES",
		"    DEPENDENCEIES",
		"        Helper scripts/functions and/or binaries needed for the function to work.",
		".PARAMETER",
		"    N parameter",
		".PARAMETER",
		"    N+1 parameter",
		".EXAMPLE",
		"    Example of how to use this cmdlet",
		".EXAMPLE",
		"    Another example of how to use this cmdlet",
		".INPUTS",
		"    Inputs to this cmdlet (if any)",
		".OUTPUTS",
		"    Output from this cmdlet (if any)",
		"#>",
		"$0"
    ],
    "description": "Help Block"
},
"Install MSI": {
    "prefix": "installmsi",
    "body": [
        "\\$DataStamp = Get-Date -Format yyyyMMddTHHmmss",
		"\\$MSIFullPath = \"\\$HOME\\Downloads\\GitDesktop.msi\"",
		"\\$MSIParentDir = \\$MSIFullPath | Split-Path -Parent",
		"\\$MSIFileName = \\$MSIFullPath | Split-Path -Leaf",
		"\\$MSIFileNameOnly = \\$MSIFileName -replace \"\\.msi\",\"\"",
		"\\$logFile = \"\\$MSIFileNameOnly\\$DataStamp.log\"",
		"\\$MSIArguments = @(",
		"    \"/i\"",
		"    \\$MSIFullPath",
		"    \"/qn\"",
		"    \"/norestart\"",
		"    \"/L*v\"",
		"    \\$logFile",
		")",
		"Start-Process \"msiexec.exe\" -ArgumentList \\$MSIArguments -Wait -NoNewWindow",
		"$0"
    ],
    "description": "Install MSI"
},
"List Type Accelerators": {
    "prefix": "getaccel",
    "body": [
		"\\$xlr=[psobject].Assembly.GetType('System.Management.Automation.TypeAccelerators')",
		"\\$xlr::Add('accelerators',\\$xlr)",
		"# The below \\$accelerators is a System.Collections.Generic.Dictionary`2",
		"\\$accelerators = [accelerators]::get",
		"# To change \\$accelerators to an object that the Where-Object cmdlet works against, do the following:",
		"[System.Collections.Hashtable] = \\$accelerators",
		"\\$acceleratorsEnum = \\$accelerators.GetEnumerator()",
		"\\$acceleratorsEnum | Where-Object {\\$_.Name -eq \"pscustomobject\"}",
		"$0"
    ],
    "description": "Install MSI"
},
"Module Manifest": {
    "prefix": "modulemanifest",
    "body": [
        "# For more information, see: https://msdn.microsoft.com/en-us/powershell/reference/4.0/microsoft.powershell.core/new-modulemanifest",
		"\\$ModuleName = \"UserSessionEx\"",
		"",
		"\\$Params = @{",
		"    Path = \"\\$(\\$(Get-Location).Path)\\\\$ModuleName.psd1\"",
		"    Author = \"pldmgg\"",
		"    ModuleToProcess = \".\\\\$ModuleName.psm1\"",
		"    CompanyName = \"Boop\"",
		"    FunctionsToExport = \"Get-UserSessionViaQuery\",\"Get-UserSessionViaCim\",\"Get-WsManServerInfo\",\"Get-UserSessionEx\"",
		"    Description = \"Get all available User Session information for one or more hosts\"",
		"    FileList = \"\\$ModuleName.psm1\",\"\\$ModuleName.psd1\"",
		"    HelpInfoUri = \"http://pldmgg.github.io/misc-powershell\"",
		"    LicenseUri = \"http://www.apache.org/licenses/LICENSE-2.0\"",
		"    ModuleVersion = \"0.9\"",
		"    PowerShellVersion = \"5.0\"",
		"}",
		"New-ModuleManifest @Params",
		"$0"
    ],
    "description": "Module Manifest"
},
"Filter Block": {
    "prefix": "filter",
    "body": [
        "Filter FilterName {",
		"    if (\\$_ -eq 2) {",
		"        \\$_",
		"        break",
		"    }",
		"}",
		"@(1,2,3) | FilterName",
		"$0"
    ],
    "description": "Filter Block"
},
"Download NuGet Package": {
    "prefix": "nugetdl",
    "body": [
        "Write-Host \"Downloading \\$assembly...\"",
		"\\$NewAssemblyDir = \"\\$HOME\\Downloads\\\\$assembly\"",
		"\\$NewAssemblyDllPath = \"\\$NewAssemblyDir\\\\$assembly.dll\"",
		"if (!\\$(Test-Path \\$NewAssemblyDir)) {",
		"    New-Item -ItemType Directory -Path \\$NewAssemblyDir",
		"}",
		"if (Test-Path \"\\$NewAssemblyDir\\\\$assembly*.zip\") {",
		"    Remove-Item \"\\$NewAssemblyDir\\\\$assembly*.zip\" -Force",
		"}",
		"\\$OutFileBaseNamePrep = Invoke-WebRequest \"https://www.nuget.org/api/v2/package/\\$assembly\" -DisableKeepAlive -UseBasicParsing",
		"\\$OutFileBaseName = \\$(\\$OutFileBaseNamePrep.BaseResponse.ResponseUri.AbsoluteUri -split \"/\")[-1] -replace \"nupkg\",\"zip\"",
		"Invoke-WebRequest -Uri \"https://www.nuget.org/api/v2/package/\\$assembly\" -OutFile \"\\$NewAssemblyDir\\\\$OutFileBaseName\"",
		"if (\\$PSVersionTable.PSEdition -eq \"Core\") {",
		"    foreach (\\$subdir in \\$PotentialZipSubDirs) {",
		"        try {",
		"            Unzip-File -PathToZip \"\\$NewAssemblyDir\\\\$OutFileBaseName\" -TargetDir \\$NewAssemblyDir -SpecificItem \"\\$subdir\\\\$assembly.dll\"",
		"            if (\\$?) {",
		"                \\$FoundSubdir = \\$true",
		"            }",
		"        }",
		"        catch {",
		"            Write-Error \"\\$subdir\\\\$assembly.dll not found...\"",
		"        }",
		"",
		"        if (\\$FoundSubdir) {",
		"            break",
		"        }",
		"    }",
		"}",
		"$0"
    ],
    "description": "Download NuGet Package"
},
"Function Parameters": {
    "prefix": "params",
    "body": [
        "# See: https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.core/about/about_functions_advanced_parameters",
		"[Parameter(",
		"    Mandatory=\\$False,",
		"    Position=0,",
		"    ParameterSetName='Parameter Set 1',",
		"    ValueFromPipeline=\\$true,",
		"    ValueFromPipelineByPropertyName=\\$true,",
		"    ValueFromRemainingArguments=\\$false,",
		"    HelpMessage=\"Enter one or more directory paths names separated by commas.\"",
		")]",
		"[Alias(\"asdf\")]",
		"[AllowNull()]",
		"[AllowEmptyString()]",
		"[AllowEmptyCollection()]",
		"[ValidateCount(0,5)]",
		"[ValidateLength(1,10)]",
		"[ValidatePattern(\"[a-z]*\")]",
		"[ValidateRange(0,5)]",
		"[ValidateScript({\\$true})]",
		"[ValidateSet(\"sun\",\"moon\",\"earth\")]",
		"[ValidateNotNull()]",
		"[ValidateNotNullOrEmpty()]",
		"[string]\\$WorkingDir,",
		"$0"
    ],
    "description": "Function Parameters"
},
"Ping W PowerShell": {
    "prefix": "ping",
    "body": [
		"Test-Connection -Count 9999 -ComputerName COMPUTERNAME | Format-Table @{Name='TimeStamp';Expression={Get-Date}},Address,ProtocolAddress,ResponseTime",
		"$0"
    ],
    "description": "Ping W PowerShell"
},
"Process Start": {
    "prefix": "processstart",
    "body": [
        "\\$ProcessInfo = New-Object System.Diagnostics.ProcessStartInfo",
		"\\$ProcessInfo.FileName = \"ssh.exe\"",
		"\\$ProcessInfo.RedirectStandardError = \\$true",
		"\\$ProcessInfo.RedirectStandardOutput = \\$true",
		"\\$ProcessInfo.UseShellExecute = \\$false",
		"\\$ProcessInfo.Arguments = \"-T git@github.com\"",
		"\\$Process = New-Object System.Diagnostics.Process",
		"\\$Process.StartInfo = \\$ProcessInfo",
		"\\$Process.Start() | Out-Null",
		"\\$Process.WaitForExit()",
		"\\$stdout = \\$Process.StandardOutput.ReadToEnd()",
		"\\$stderr = \\$Process.StandardError.ReadToEnd()",
		"\\$AllOutput = \\$stdout + \\$stderr",
		"$0"
    ],
    "description": "Process Start"
},
"Proxy Function": {
    "prefix": "proxyfunction",
    "body": [
        "function Get-ProcessBetter {",
		"    <#",
		"        For more information about proxy functions, see the following article on the",
		"        Microsoft PowerShell Team blog:",
		"        http://blogs.msdn.com/powershell/archive/2009/01/04/extending-and-or-modifing-commands-with-proxies.aspx",
		"    #>",
		"    <#",
		"        To create a proxy function for the Get-Process cmdlet, paste the results of the following command into the body of this function and then remove this comment:",
		"        [Management.Automation.ProxyCommand]::Create((New-Object Management.Automation.CommandMetaData (Get-Command Get-Process)))",
		"    #>",
		"}",
		"$0"
    ],
    "description": "Proxy Function"
},
"PS Credential": {
    "prefix": "pscred",
    "body": [
		"\\$Credentials = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \\$UserName, \\$Pwd",
		"$0"
    ],
    "description": "PS Credential"
},
"PS Custom Object": {
    "prefix": "psobject",
    "body": [
        "New-Variable -Name \"VariableName\" -Value \\$(",
		"    [pscustomobject][ordered]@{",
		"        Key1   = \"Value1\"",
		"        Key2   = \"Value2\"",
		"        Key3   = \"Value3\"",
		"    }",
		")",
		"$0"
    ],
    "description": "PS Custom Object"
},
"PowerShell Class": {
    "prefix": "psclass",
    "body": [
        "# http://powershelldistrict.com/powershell-class/",
		"Class Computer {",
		"    [String]\\$Name",
		"    [String]\\$Type",
		"    [string]\\$Description",
		"    [string]\\$owner",
		"    [string]\\$Model",
		"    [int]\\$Reboots",
		"",
		"    # Method",
		"    [void]Reboot(){",
		"        \\$this.Reboots ++",
		"    }",
		"",
		"    # Class Constructor (one way of instantiating a new object)",
		"    Computer ([string]\\$Name){",
		"        if (\\$comp = Get-ADComputer -filter \"name -eq '\\$Name'\" -Properties * -ErrorAction SilentlyContinue){",
		"            \\$this.name =\\$Name",
		"            \\$this.Description = \\$Comp.Description",
		"",
		"            switch -wildcard (\\$comp.OperatingSystem){",
		"                ('*Server*') {\\$this.Type = 'Server';Break}",
		"                ('*workstation*') {\\$this.Type = 'Workstation'}",
		"                ('*Laptop*') {\\$this.Type = 'Laptop';Break}",
		"                default { \\$this.Type = 'N/A'}",
		"            ",
		"            }",
		"           \\$this.owner = \\$comp.ManagedBy.Split(',')[0].replace('CN=','')",
		"        }else{",
		"            write-verbose \"Could Not find \\$(\\$this.name)\"",
		"        }",
		"        ",
		"    }",
		"",
		"    # Class Constructor (another way of instantiating a new object)",
		"    Computer ([string]\\$Name, [String]\\$type,[string]\\$Description,[string]\\$owner,[String]\\$Model){",
		"        if (!(\\$comp = Get-ADComputer -filter \"name -eq '\\$Name'\" -Properties name)){",
		" ",
		"            ",
		"            if (\\$user = Get-ADUser -Filter \"name -eq '\\$owner'\"){",
		"            ",
		"                try{",
		"                   New-ADComputer -Name \\$Name -Description \\$Description -ManagedBy \\$user -ErrorAction Stop",
		"                    \\$this.Name = \\$Name",
		"                    \\$this.Type = \\$type",
		"                    \\$this.Description = \\$Description",
		"                    \\$this.owner = \\$owner     ",
		"                }catch{",
		"                    \\$_",
		"                } ",
		"            }else{",
		"                write-warning \"the user \\$(\\$Owner) is not existing. Please verify and try again.\"",
		"            }",
		"        }",
		"        ",
		"    }",
		"}",
		"$0"
    ],
    "description": "PowerShell Class"
},
"Random String": {
    "prefix": "randstring",
    "body": [
		"# Letters only 10 characters long:",
		"\\$randstring = -join ((1..10) | %{(65..90) + (97..122) | Get-Random} | % {[char]\\$_})",
		"",
		"# Letters and numbers 10 characters long",
		"\\$randstring = -join (0..10 | % {[char][int]((65..90) + (97..122) + (48..57) | Get-Random)})",
		"",
		"# Letters, numbers, and symbols 10 characters long",
		"\\$randstring = -join (0..10 | % {[char][int]((65..90) + (97..122) + (48..57) + (35,36,42,43,44,45,46,47,58,59,61,63,64,91,92,93,95,123,125,126) | Get-Random)})",
		"$0"
    ],
    "description": "Random String"
},
"Registry Management": {
    "prefix": "registry",
    "body": [
        "<#",
		"Registry PropertyType Reference:",
		"",
		"REG_SZ = String ",
		"REG_DWORD = DWord ",
		"REG_QWORD = QWord ",
		"REG_MULTI_SZ = MultiString ",
		"REG_BINARY = Binary",
		"#>",
		"",
		"if (!\\$(Test-Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation)) {",
		"    New-Item -Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation",
		"}",
		"if (!\\$(Test-Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation\\AllowDefaultCredentials)) {",
		"    New-Item -Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation\\AllowDefaultCredentials",
		"}",
		"Set-ItemProperty -Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation -Name AllowFreshCredentials -Value 1 -Type DWord",
		"Set-ItemProperty -Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation -Name ConcatenateDefaults_AllowFresh -Value 1 -Type DWord",
		"Set-ItemProperty -Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation -Name 1 -Value WSMAN/\\$env:COMPUTERNAME.\\$(\\$(Get-CimInstance -ClassName Win32_ComputerSystem).Domain) -Type String",
		"$0"
    ],
    "description": "Registry Management"
},
"Resolve Path": {
    "prefix": "resolvepath",
    "body": [
        "if (-not (Test-Path \\$Path)) {",
		"    New-Item -ItemType Directory -Path \\$Path -ErrorAction Stop | Out-Null",
		"}",
		"\\$FinalPath = (Resolve-Path \\$Path -ErrorAction Stop).ProviderPath",
		"$0"
    ],
    "description": "Resolve Path"
},
"CSharp": {
    "prefix": "csharp",
    "body": [
        "# NuGet Packages downloaded/installed via Visual Studio Project can be found here:",
		"# \\$HOME\\.nuget\\packages",
		"",
		"###### If the appropriate Assembly is already in the GAC under C:\\Windows\\Microsoft.Net\\assembly\\GAC_MSIL #####",
		"\\$AssemblyDllFilePath = [System.Reflection.Assembly]::LoadWithPartialName('System.Net.NetworkInformation').Location",
		"\\$AssemblyFullInfo = [System.Reflection.Assembly]::LoadWithPartialName('System.Net.NetworkInformation').FullName",
		"\\$AssemblyFullInfoFromDll = [System.Reflection.AssemblyName]::GetAssemblyName(\\$AssemblyDllFilePath).FullName",
		"",
		"###### If you need to download the assembly from NuGet... #####",
		"## If you are planning on running the CSharp code on .Net Framework 45 or 46 ##",
		"# Get the .dll under lib\\net45 or lib\\46...",
		"\\$NewNewtonSoftDir = \"\\$HOME\\Downloads\\NewtonSoft-JSON\"",
		"\\$NewtonSoftJsonAssemblyDllPath = \"\\$NewNewtonSoftDir\\Newtonsoft.Json.dll\"",
		"if (!\\$(Test-Path \\$NewNewtonSoftDir)) {",
		"    New-Item -ItemType Directory -Path \\$NewNewtonSoftDir",
		"    Invoke-WebRequest -Uri \"https://www.nuget.org/api/v2/package/Newtonsoft.Json/9.0.1\" -OutFile \"\\$NewNewtonSoftDir\\newtonsoft.json.9.0.1.zip\"",
		"    Unzip-File -PathToZip \"\\$NewNewtonSoftDir\\newtonsoft.json.9.0.1.zip\" -TargetDir \\$NewNewtonSoftDir -SpecificItem \"lib\\net45\\Newtonsoft.Json.dll\"",
		"}",
		"# ...and feel free to run under normal PowerShell implementation (such as PowerShell 5.1 which runs on .Net Framework 4.0)",
		"",
		"## If you are planning on running CSharp code on PowerShell Core, ##",
		"# Get the .dll under the lib\netcore50 or lib\netstandard1.X",
		"\\$NewNewtonSoftDir = \"\\$HOME\\Downloads\\NewtonSoft-JSON\"",
		"\\$NewtonSoftJsonAssemblyDllPath = \"\\$NewNewtonSoftDir\\Newtonsoft.Json.dll\"",
		"if (!\\$(Test-Path \\$NewNewtonSoftDir)) {",
		"    New-Item -ItemType Directory -Path \\$NewNewtonSoftDir",
		"    Invoke-WebRequest -Uri \"https://www.nuget.org/api/v2/package/Newtonsoft.Json/9.0.1\" -OutFile \"\\$NewNewtonSoftDir\\newtonsoft.json.9.0.1.zip\"",
		"    Unzip-File -PathToZip \"\\$NewNewtonSoftDir\\newtonsoft.json.9.0.1.zip\" -TargetDir \\$NewNewtonSoftDir -SpecificItem \"lib\\netcore50\\Newtonsoft.Json.dll\"",
		"}",
		"# ...and run under PowerShell Core. ",
		"# NOTE: Dependencies are most likely radically different under for Core! It's probably easiest to build",
		"# a Visual Studio project, target .Net Core framework, use NuGet in Visual Studio to download the dependencies",
		"# and get the downloaded .dll files in \\$HOME\\.nuget\\packages",
		"",
		"# IMPORTANT NOTE: If some dependency assemblies already exist in the GAC, and the version in the GAC is",
		"# insufficient you need to remove it before installing the new version! Be very careful with removing",
		"# assemblies from the GAC. In general, NEVER remove any existing GAC assembly with \"System\" in the",
		"# AppDomain name.",
		"# (To remove, see \"\\$publish.GacRemove(\\$OldAssemblyLocation)\" below)",
		"",
		"# After downloading the new assembly, install to the GAC via the following:",
		"\\$AssemblyDllFilePath = \"\\$HOME\\Downloads\\Newtonsoft.JSON\\lib\\netstandard1.3\\Newtonsoft.Json.dll\"",
		"",
		"# Publish to the GAC using the following",
		"[System.Reflection.Assembly]::LoadWithPartialName(\"System.EnterpriseServices\")",
		"\\$publish = New-Object System.EnterpriseServices.Internal.Publish",
		"\\$publish.GacInstall(\\$AssemblyDllFilePath)",
		"#\\$publish.GacRemove(\\$OldAssemblyLocation)",
		"",
		"",
		"###### Run the inline CSharp using the Add-Type cmdlet as below #####",
		"\\$Assem = @(",
		"    \\$AssemblyFullInfo",
		")",
		"",
		"\\$Source = @\"",
		"using System;",
		"using System.Net.NetworkInformation;",
		"",
		"namespace PaulD.IPTools",
		"{ ",
		"    public static class TCPConnections",
		"    {",
		"        public static void ShowActiveTcpConnections()",
		"        {",
		"            Console.WriteLine(\"Active TCP Connections\");",
		"            IPGlobalProperties properties = IPGlobalProperties.GetIPGlobalProperties();",
		"            TcpConnectionInformation[] connections = properties.GetActiveTcpConnections();",
		"            foreach (TcpConnectionInformation c in connections)",
		"            {",
		"                Console.WriteLine(\"{0} <==> {1}\",",
		"                                  c.LocalEndPoint.ToString(),",
		"                                  c.RemoteEndPoint.ToString());",
		"            }",
		"        }",
		"    }",
		"}",
		"\"@",
		"",
		"Add-Type -ReferencedAssemblies \\$Assem -TypeDefinition \\$Source -Language CSharp",
		"",
		"[PaulD.IPTools.TCPConnections]::ShowActiveTcpConnections()",
		"$0"
    ],
    "description": "CSharp"
},
"Secure String": {
    "prefix": "securestring",
    "body": [
        "# Convert PlainText to SecureString",
		"\\$SampleSecureString = ConvertTo-SecureString 'MySuperSecretP@ssw0rd!' -AsPlainText -Force",
		"",
		"# Convert SecureString to PlainText",
		"[Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR())",
		"$0"
    ],
    "description": "Secure String"
},
"Send Email": {
    "prefix": "sendemail",
    "body": [
        "\\$emailParameters = @{",
		"    From = \"user@domain.com\"",
		"    To = \"user1@domain.com, User2 <user2@domain.com>\"",
		"    Subject = \"Notice of script failure\"",
		"    Body = \"The following script failed...\"",
		"    SmtpServer = \"smtp.domain.com\"",
		"    Credential = \"domain01\\admin01\"",
		"}",
		"",
		"Send-MailMessage @emailParameter",
		"$0"
    ],
    "description": "Send Email"
},
"Send Key": {
    "prefix": "sendkey",
    "body": [
        "# For more info on SendKeys method, see: https://msdn.microsoft.com/en-us/library/office/aa202943(v=office.10).aspx",
		"Sleep 1",
		"\\$OpenWindowTitle = \\$(Get-Process | Where-Object {\\$_.MainWindowTitle -like \"Application Install*\"}).MainWindowTitle",
		"\\$wshell = New-Object -ComObject wscript.shell",
		"\\$wshell.AppActivate(\"\\$OpenWindowTitle\") | Out-Null",
		"Sleep 1",
		"\\$wshell.SendKeys('{LEFT}')",
		"$0"
    ],
    "description": "Send Key"
},
"Should Process": {
    "prefix": "shouldprocess",
    "body": [
        "# Below \\$pscmdlet is type system.management.automation.pscmdlet",
		"# For good Example Usage, see Publish-MyGitRepo.ps1",
		"# For more info,, see: https://msdn.microsoft.com/en-us/library/system.management.automation.pscmdlet(v=vs.85).aspx",
		"",
		"if (\\$pscmdlet.ShouldProcess('Target','OperationMsg'))",
		"{",
		"    ",
		"}",
		"$0"
    ],
    "description": "Should Process"
},
"Splat Parameters": {
    "prefix": "splatparams",
    "body": [
        "\\$Params = @{",
		"    MountName = \"Installers\"",
		"    MountDriveLetter = \"\\$env:InstallersMountDriveLetter\"",
		"    NetworkPath = \"\\\\pdhyper216.pddomain2.lab\\E_Master_Share\\installers\"",
		"    UserAndPwdCredential = \\$fileshare_credential",
		"}",
		"Mount-WindowsFileShare @Params",
		"$0"
    ],
    "description": "Splat Parameters"
},
"Split Path": {
    "prefix": "splitpath",
    "body": [
        "\\$testpath = \"C:\\Users\\testadmin\\test.doc\"",
		"\\$ParentDir = \\$testpath | Split-Path -Parent",
		"\\$File = \\$testpath | Split-Path -Leaf",
		"$0"
    ],
    "description": "Split Path"
},
"Split String": {
    "prefix": "splitstring",
    "body": [
        "\\$pos = \\$PSCommandPath.LastIndexOf(\"\\\")",
		"\\$ScriptDir = \\$PSCommandPath.Substring(0, \\$pos)",
		"\\$ScriptFile = \\$PSCommandPath.Substring(\\$pos+1)",
		"$0"
    ],
    "description": "Split String"
},
"Switch": {
    "prefix": "switch",
    "body": [
        "# If \\$x -eq 'Value1', break; If \\$x in \\$array, do the scriptblock;",
		"# If \\$x -eq 'Value3', break; Else, do the Default scriptblock",
		"switch (\\$x)",
		"{",
		"    'Value1' {",
		"",
		"        break",
		"    }",
		"",
		"    {\\$_ -in \\$array} {}",
		"",
		"    'Value3' {",
		"",
		"        break",
		"    }",
		"    Default {}",
		"}",
		"$0"
    ],
    "description": "Switch"
},
"Try Catch Finally": {
    "prefix": "trycatchfinally",
    "body": [
        "<#",
		"    IMPORTANT NOTE 1: Before using try-catch-finally, make sure environment variable \\$ErrorActionPreference = \"Stop\"",
		"    as opposed to \"Continue\"",
		"",
		"    IMPORTANT NOTE 2: Find the full Error Name by using the following command immediately after failed command:",
		"    \\$Error[0].exception.GetType().fullname",
		"",
		"    IMPORTANT NOTE 3: For errors pertaining to the cmdlet Add-Type (for adding .Net Assemblies), use the following",
		"    to see what dependencies didn't load:",
		"    try",
		"    {",
		"        Add-Type -Path \"C:\\Users\\testadmin\\Downloads\\EPPlus.Core.dll\"",
		"    }",
		"    catch",
		"    {",
		"        \\$Error[0].Exception.LoaderExceptions",
		"    }",
		"#>",
		"",
		"try",
		"{",
		"    1/0",
		"    #Test-Connection bleh",
		"}",
		"catch [DivideByZeroException]",
		"{",
		"    Write-Host \"Divide by zero exception\"",
		"}",
		"catch [System.Net.NetworkInformation.PingException]",
		"{",
		"    Write-Host \"Ping exception\"",
		"}",
		"catch",
		"{",
		"    Write-Host \"General catch\"",
		"    Write-Verbose \"Error creating \\$Name on \\$Computer`:\\$([0].Exception.Message)\"",
		"}",
		"finally",
		"{",
		"    Write-Host \"cleaning up ...\"",
		"}",
		"$0"
    ],
    "description": "Try Catch Finally"
},
"While": {
    "prefix": "while",
    "body": [
        "while (\\$x -gt 0)",
		"{",
		"",
		"}",
		"$0"
    ],
    "description": "While"
},
"WinRM Config": {
    "prefix": "winrmconfig",
    "body": [
        "# Configure Service",
		"<#",
		"Set-Item -Path WSMan:\\localhost\\Service\\MaxConcurrentOperations -Value 4294967295 # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\MaxConcurrentOperationsPerUser -Value 1500 # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\EnumerationTimeoutms -Value 240000 # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\MaxConnections -Value 300 # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\MaxPacketRetrievalTimeSeconds -Value 120 # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\AllowUnencrypted -Value \\$false # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\IPv4Filter -Value \"*\" # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\IPv6Filter -Value \"*\" # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\EnableCompatibilityHttpListener -Value \\$false # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\EnableCompatibilityHttpsListener -Value \\$false # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\CertificateThumbprint -Value \"\" # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\AllowRemoteAccess -Value \\$true # Configured by default",
		"#>",
		"",
		"# Configure Service Authentication",
		"Set-Item -Path WSMan:\\localhost\\Service\\Auth\\Basic -Value \\$false # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\Auth\\Digest -Value \\$true # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\Auth\\Kerberos -Value \\$true # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\Auth\\Negotiate -Value \\$true # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\Auth\\Certificate -Value \\$true # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Service\\Auth\\CredSSP -Value \\$false # Configured by default",
		"",
		"",
		"# Configure Client",
		"Set-Item -Path WSMan:\\localhost\\Client\\Auth\\Basic -Value \\$false # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Client\\Auth\\Digest -Value \\$true # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Client\\Auth\\Kerberos -Value \\$true # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Client\\Auth\\Negotiate -Value \\$true # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Client\\Auth\\Certificate -Value \\$true # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Client\\Auth\\CredSSP -Value \\$false # Configured by default",
		"#>",
		"",
		"# Configure Shell",
		"<#",
		"Set-Item -Path WSMan:\\localhost\\Shell\\AllowRemoteShellAccess -Value \\$true # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Shell\\IdleTimeout -Value 7200000 # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Shell\\MaxConcurrentUsers -Value 2147483647 # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Shell\\MaxShellRunTime -Value 2147483647 # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Shell\\MaxProcessesPerShell -Value 2147483647 # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Shell\\MaxMemoryPerShellMB -Value 2147483647 # Configured by default",
		"Set-Item -Path WSMan:\\localhost\\Shell\\MaxShellsPerUser -Value 2147483647 # Configured by default",
		"#>",
		"",
		"# Configure Trusted Hosts",
		"if (Get-Elevation) {",
		"    \\$CurrentTrustedHosts = \\$(ls WSMan:\\localhost\\Client\\TrustedHosts).Value",
		"    \\$UpdatedTrustedHostsArrayPrep = \\$CurrentTrustedHosts -split ", "",
		"    [System.Collections.ArrayList]\\$UpdatedTrustedHostsArray = \\$UpdatedTrustedHostsArrayPrep",
		"    \\$NeededUpdates = @()",
		"    foreach (\\$obj1 in \\$RemoteHostNetworkInfoArray) {",
		"        if (\\$UpdatedTrustedHostsArrayPrep -notcontains \\$obj1) {",
		"            \\$UpdatedTrustedHostsArray.Add(\"\\$obj1\")",
		"            \\$NeededUpdates += \\$obj1",
		"        }",
		"    }",
		"    if (\\$NeededUpdates.Count -gt 0) {",
		"        \\$UpdatedTrustedHostsArray = \\$UpdatedTrustedHostsArray | % {if (\\$_ -match \"[\\w]\") {\\$_}}",
		"        \\$UpdatedTrustedHostsArrayString = \\$UpdatedTrustedHostsArray -join ", "",
		"        Set-Item WSMan:\\localhost\\Client\\TrustedHosts \\$UpdatedTrustedHostsArrayString",
		"        Remove-Variable -Name NeededUpdates -Force",
		"    }",
		"    else {",
		"        Write-Host \"The current winrm config already trusts \\$RemoteHost. Continuing...\"",
		"    }",
		"}",
		"",
		"# Create New WinRM Listener",
		"New-Item -Path WSMan:\\localhost\\Listener -Address \"*\" -Transport \"HTTP\" -Port \"5985\" -Enabled \\$true -URLPrefix \"wsman\"",
		"$0"
    ],
    "description": "WinRM Config"
},
"WinSCP": {
    "prefix": "winscp",
    "body": [
        "if (\\$(Check-InstalledPrograms -ProgramTitleSearchTerm \"WinSCP\").DisplayName -ne ) {",
		"    Invoke-WebRequest -Uri \"https://cdn.winscp.net/files/WinSCP-5.9.5-Automation.zip?secure=FS9qKIgo7Mzm7TR6kXeRLA==,1496675795\" -OutFile \"\\$HOME\\Downloads\\WinSCP-5.9.5-Automation.zip\"",
		"    if (!\\$(Test-Path \"\\$HOME\\Downloads\\WinSCP\")) {",
		"        New-Item -Type Directory -Path \"\\$HOME\\Downloads\\WinSCP\"",
		"    }",
		"    Unzip-File -PathToZip \"\\$HOME\\Downloads\\WinSCP-5.9.5-Automation.zip\" -TargetDir \"\\$HOME\\Downloads\\WinSCP\"",
		"",
		"    # Note: Add-Type doesn't work with WinSCPnet.dll for some reason, so using .Net LoadFile method",
		"    # Add-Type \"\\$HOME\\Downloads\\WinSCP\\WinSCPnet.dll\"",
		"    [System.Reflection.Assembly]::LoadFile(\"\\$HOME\\Downloads\\WinSCP\\WinSCPnet.dll\")",
		"}",
		"$0"
    ],
    "description": "WinSCP"
},
"View Loaded Assemblies": {
    "prefix": "viewassemblies",
    "body": [
		"[System.AppDomain]::CurrentDomain.GetAssemblies()",
		"$0"
    ],
    "description": "View Loaded Assemblies"
}
}